"use strict";(self.webpackChunkliangchao_website=self.webpackChunkliangchao_website||[]).push([[8457],{2874:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var s=t(6481),i=t(4848),a=t(8453);const o={slug:"canopy-photosynthesis-modeling-en",title:"Canopy Photosynthesis Modeling Tutorial Based on 3D Reconstruction",authors:["liangchao"],tags:["plant phenotyping","3d reconstruction","photosynthesis","computer vision","ray tracing"]},r="Canopy Photosynthesis Modeling Tutorial Based on 3D Reconstruction",l={authorsImageUrls:[void 0]},c=[{value:"Introduction",id:"introduction",level:2},{value:"Technical Workflow Overview",id:"technical-workflow-overview",level:2},{value:"Step 1: Multi-view Image Acquisition System",id:"step-1-multi-view-image-acquisition-system",level:2},{value:"Hardware Configuration",id:"hardware-configuration",level:3},{value:"Adaptive Capture Strategy",id:"adaptive-capture-strategy",level:3},{value:"Step 2: Structure from Motion (SfM) Reconstruction",id:"step-2-structure-from-motion-sfm-reconstruction",level:2},{value:"COLMAP Integration",id:"colmap-integration",level:3},{value:"Step 3: 3D Gaussian Splatting Reconstruction",id:"step-3-3d-gaussian-splatting-reconstruction",level:2},{value:"Step 4: Mesh Processing and Plant Model Construction",id:"step-4-mesh-processing-and-plant-model-construction",level:2},{value:"Step 5: Canopy Construction with Random Perturbation",id:"step-5-canopy-construction-with-random-perturbation",level:2},{value:"Step 6: Ray Tracing Algorithm Implementation",id:"step-6-ray-tracing-algorithm-implementation",level:2},{value:"Step 7: Light Response Curve Model",id:"step-7-light-response-curve-model",level:2},{value:"Step 8: Complete Workflow Integration",id:"step-8-complete-workflow-integration",level:2},{value:"Conclusion",id:"conclusion",level:2}];function p(n){const e={code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(e.p,{children:"Canopy photosynthesis modeling is a crucial research area in precision agriculture and plant phenomics. This comprehensive tutorial demonstrates how to build a complete canopy photosynthesis simulation system through multi-view image acquisition, 3D reconstruction, canopy construction, and ray tracing techniques. The complete workflow includes: Camera Capture \u2192 SfM/3DGS Reconstruction \u2192 Mesh Generation \u2192 Canopy Construction \u2192 Light Distribution Simulation \u2192 Photosynthesis Calculation."}),"\n",(0,i.jsx)(e.h2,{id:"technical-workflow-overview",children:"Technical Workflow Overview"}),"\n",(0,i.jsx)(e.mermaid,{value:"graph TD\n    A[Multi-view Image Capture] --\x3e B[SfM 3D Reconstruction]\n    A --\x3e C[3D Gaussian Splatting]\n    B --\x3e D[Point Cloud Generation]\n    C --\x3e D\n    D --\x3e E[Triangle Mesh Generation]\n    E --\x3e F[Plant Mesh Model]\n    F --\x3e G[Plant Replication & Perturbation]\n    G --\x3e H[3D Canopy Model]\n    H --\x3e I[Ray Tracing Algorithm]\n    I --\x3e J[Light Distribution Calculation]\n    J --\x3e K[Light Response Curve Model]\n    K --\x3e L[Canopy Photosynthesis Rate]"}),"\n",(0,i.jsx)(e.h2,{id:"step-1-multi-view-image-acquisition-system",children:"Step 1: Multi-view Image Acquisition System"}),"\n",(0,i.jsx)(e.h3,{id:"hardware-configuration",children:"Hardware Configuration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"# Multi-view capture system configuration\nimport numpy as np\nimport cv2\nimport json\nfrom datetime import datetime\n\nclass MultiViewCaptureSystem:\n    def __init__(self, camera_config):\n        self.cameras = []\n        self.calibration_data = {}\n        self.capture_positions = self.generate_capture_positions()\n        \n    def generate_capture_positions(self, radius=1.5, height_levels=3, angles_per_level=12):\n        \"\"\"Generate spherical capture positions\"\"\"\n        positions = []\n        \n        for h_idx in range(height_levels):\n            # Height from 0.5m to 2.0m\n            height = 0.5 + (h_idx * 0.75)\n            \n            for angle_idx in range(angles_per_level):\n                angle = (angle_idx * 360 / angles_per_level) * np.pi / 180\n                \n                x = radius * np.cos(angle)\n                y = radius * np.sin(angle)\n                z = height\n                \n                # Camera looks at plant center\n                look_at = np.array([0, 0, 1.0])  # Plant center height\n                camera_pos = np.array([x, y, z])\n                \n                positions.append({\n                    'position': camera_pos,\n                    'look_at': look_at,\n                    'up_vector': np.array([0, 0, 1])\n                })\n        \n        return positions\n    \n    def capture_sequence(self, plant_id, output_dir):\n        \"\"\"Execute multi-view image capture\"\"\"\n        metadata = {\n            'plant_id': plant_id,\n            'timestamp': datetime.now().isoformat(),\n            'positions': [],\n            'camera_params': self.get_camera_parameters()\n        }\n        \n        for idx, pos_config in enumerate(self.capture_positions):\n            # Move camera to specified position (requires robotic arm or rail system)\n            self.move_camera_to_position(pos_config)\n            \n            # Capture image\n            image_path = f\"{output_dir}/image_{idx:03d}.jpg\"\n            image = self.capture_image()\n            cv2.imwrite(image_path, image)\n            \n            # Record position information\n            metadata['positions'].append({\n                'image_id': idx,\n                'position': pos_config['position'].tolist(),\n                'look_at': pos_config['look_at'].tolist(),\n                'up_vector': pos_config['up_vector'].tolist()\n            })\n        \n        # Save metadata\n        with open(f\"{output_dir}/metadata.json\", 'w') as f:\n            json.dump(metadata, f, indent=2)\n        \n        return metadata\n    \n    def get_camera_parameters(self):\n        \"\"\"Get camera intrinsic parameters\"\"\"\n        return {\n            'focal_length': 35.0,  # mm\n            'sensor_width': 36.0,  # mm\n            'sensor_height': 24.0,  # mm\n            'image_width': 4000,\n            'image_height': 3000,\n            'distortion_coeffs': [0.1, -0.2, 0.0, 0.0, 0.0]\n        }\n"})}),"\n",(0,i.jsx)(e.h3,{id:"adaptive-capture-strategy",children:"Adaptive Capture Strategy"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class AdaptiveCaptureStrategy:\n    def __init__(self):\n        self.quality_threshold = 0.8\n        self.overlap_ratio = 0.6\n        \n    def optimize_capture_positions(self, plant_bbox, complexity_map):\n        """Optimize capture positions based on plant complexity"""\n        base_positions = self.generate_base_positions(plant_bbox)\n        \n        # Increase capture density based on plant complexity\n        enhanced_positions = []\n        for pos in base_positions:\n            enhanced_positions.append(pos)\n            \n            # Add extra views in complex regions\n            complexity = self.estimate_local_complexity(pos, complexity_map)\n            if complexity > 0.7:\n                additional_views = self.generate_additional_views(pos, num_views=3)\n                enhanced_positions.extend(additional_views)\n        \n        return enhanced_positions\n    \n    def estimate_image_quality(self, image):\n        """Evaluate image quality"""\n        # Calculate image sharpness\n        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n        laplacian_var = cv2.Laplacian(gray, cv2.CV_64F).var()\n        \n        # Calculate exposure quality\n        hist = cv2.calcHist([gray], [0], None, [256], [0, 256])\n        exposure_quality = 1.0 - np.sum(hist[[0, 255]]) / image.size\n        \n        # Overall quality score\n        quality_score = (laplacian_var / 1000.0) * exposure_quality\n        return min(quality_score, 1.0)\n'})}),"\n",(0,i.jsx)(e.h2,{id:"step-2-structure-from-motion-sfm-reconstruction",children:"Step 2: Structure from Motion (SfM) Reconstruction"}),"\n",(0,i.jsx)(e.h3,{id:"colmap-integration",children:"COLMAP Integration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'import subprocess\nimport os\nfrom pathlib import Path\n\nclass SfMReconstruction:\n    def __init__(self, colmap_path="/usr/local/bin/colmap"):\n        self.colmap_path = colmap_path\n        \n    def run_sfm_pipeline(self, image_dir, output_dir, camera_model="PINHOLE"):\n        """Execute complete SfM reconstruction pipeline"""\n        \n        # Create output directory\n        Path(output_dir).mkdir(parents=True, exist_ok=True)\n        database_path = os.path.join(output_dir, "database.db")\n        \n        # 1. Feature extraction\n        self.extract_features(image_dir, database_path, camera_model)\n        \n        # 2. Feature matching\n        self.match_features(database_path)\n        \n        # 3. Sparse reconstruction\n        sparse_dir = os.path.join(output_dir, "sparse")\n        self.sparse_reconstruction(database_path, image_dir, sparse_dir)\n        \n        # 4. Dense reconstruction\n        dense_dir = os.path.join(output_dir, "dense")\n        self.dense_reconstruction(image_dir, sparse_dir, dense_dir)\n        \n        return dense_dir\n    \n    def extract_features(self, image_dir, database_path, camera_model):\n        """Feature extraction"""\n        cmd = [\n            self.colmap_path, "feature_extractor",\n            "--database_path", database_path,\n            "--image_path", image_dir,\n            "--ImageReader.camera_model", camera_model,\n            "--SiftExtraction.use_gpu", "1",\n            "--SiftExtraction.max_num_features", "8192"\n        ]\n        subprocess.run(cmd, check=True)\n    \n    def match_features(self, database_path):\n        """Feature matching"""\n        cmd = [\n            self.colmap_path, "exhaustive_matcher",\n            "--database_path", database_path,\n            "--SiftMatching.use_gpu", "1"\n        ]\n        subprocess.run(cmd, check=True)\n    \n    def sparse_reconstruction(self, database_path, image_dir, output_dir):\n        """Sparse reconstruction"""\n        Path(output_dir).mkdir(parents=True, exist_ok=True)\n        \n        cmd = [\n            self.colmap_path, "mapper",\n            "--database_path", database_path,\n            "--image_path", image_dir,\n            "--output_path", output_dir\n        ]\n        subprocess.run(cmd, check=True)\n    \n    def dense_reconstruction(self, image_dir, sparse_dir, dense_dir):\n        """Dense reconstruction"""\n        Path(dense_dir).mkdir(parents=True, exist_ok=True)\n        \n        # Image undistortion\n        cmd_undistort = [\n            self.colmap_path, "image_undistorter",\n            "--image_path", image_dir,\n            "--input_path", os.path.join(sparse_dir, "0"),\n            "--output_path", dense_dir,\n            "--output_type", "COLMAP"\n        ]\n        subprocess.run(cmd_undistort, check=True)\n        \n        # Stereo matching\n        cmd_stereo = [\n            self.colmap_path, "patch_match_stereo",\n            "--workspace_path", dense_dir,\n            "--workspace_format", "COLMAP",\n            "--PatchMatchStereo.geom_consistency", "1"\n        ]\n        subprocess.run(cmd_stereo, check=True)\n        \n        # Stereo fusion\n        cmd_fusion = [\n            self.colmap_path, "stereo_fusion",\n            "--workspace_path", dense_dir,\n            "--workspace_format", "COLMAP",\n            "--input_type", "geometric",\n            "--output_path", os.path.join(dense_dir, "fused.ply")\n        ]\n        subprocess.run(cmd_fusion, check=True)\n'})}),"\n",(0,i.jsx)(e.h2,{id:"step-3-3d-gaussian-splatting-reconstruction",children:"Step 3: 3D Gaussian Splatting Reconstruction"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"import torch\nimport torch.nn as nn\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\n\nclass GaussianSplattingReconstruction:\n    def __init__(self, device=\"cuda\"):\n        self.device = device\n        self.gaussians = None\n        \n    def initialize_gaussians_from_sfm(self, point_cloud_path, num_gaussians=100000):\n        \"\"\"Initialize Gaussians from SfM point cloud\"\"\"\n        # Load SfM point cloud\n        points, colors = self.load_point_cloud(point_cloud_path)\n        \n        # Initialize Gaussian parameters\n        positions = torch.tensor(points, dtype=torch.float32, device=self.device)\n        colors = torch.tensor(colors, dtype=torch.float32, device=self.device)\n        \n        # Initialize scales and rotations\n        scales = torch.ones((len(points), 3), device=self.device) * 0.01\n        rotations = torch.zeros((len(points), 4), device=self.device)\n        rotations[:, 0] = 1.0  # Unit quaternion\n        \n        # Initialize opacities\n        opacities = torch.ones((len(points), 1), device=self.device) * 0.5\n        \n        self.gaussians = {\n            'positions': nn.Parameter(positions),\n            'colors': nn.Parameter(colors),\n            'scales': nn.Parameter(scales),\n            'rotations': nn.Parameter(rotations),\n            'opacities': nn.Parameter(opacities)\n        }\n        \n        return self.gaussians\n    \n    def train_gaussians(self, images, camera_poses, num_iterations=30000):\n        \"\"\"Train 3D Gaussians\"\"\"\n        optimizer = torch.optim.Adam([\n            {'params': [self.gaussians['positions']], 'lr': 0.00016},\n            {'params': [self.gaussians['colors']], 'lr': 0.0025},\n            {'params': [self.gaussians['scales']], 'lr': 0.005},\n            {'params': [self.gaussians['rotations']], 'lr': 0.001},\n            {'params': [self.gaussians['opacities']], 'lr': 0.05}\n        ])\n        \n        for iteration in range(num_iterations):\n            # Randomly select training view\n            cam_idx = np.random.randint(0, len(images))\n            target_image = images[cam_idx]\n            camera_pose = camera_poses[cam_idx]\n            \n            # Render image\n            rendered_image = self.render_gaussian_splatting(camera_pose)\n            \n            # Compute loss\n            loss = self.compute_loss(rendered_image, target_image)\n            \n            # Backpropagation\n            optimizer.zero_grad()\n            loss.backward()\n            optimizer.step()\n            \n            # Adaptive density control\n            if iteration % 100 == 0:\n                self.adaptive_density_control()\n            \n            if iteration % 1000 == 0:\n                print(f\"Iteration {iteration}, Loss: {loss.item():.6f}\")\n    \n    def extract_mesh_from_gaussians(self, resolution=512):\n        \"\"\"Extract mesh from Gaussians\"\"\"\n        # Use Marching Cubes algorithm\n        from skimage import measure\n        \n        # Create voxel grid\n        x = np.linspace(-2, 2, resolution)\n        y = np.linspace(-2, 2, resolution)\n        z = np.linspace(-2, 2, resolution)\n        X, Y, Z = np.meshgrid(x, y, z)\n        \n        # Calculate density for each voxel\n        density = self.evaluate_gaussian_density(X, Y, Z)\n        \n        # Extract isosurface\n        vertices, faces, _, _ = measure.marching_cubes(density, level=0.1)\n        \n        return vertices, faces\n"})}),"\n",(0,i.jsx)(e.h2,{id:"step-4-mesh-processing-and-plant-model-construction",children:"Step 4: Mesh Processing and Plant Model Construction"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'import trimesh\nimport open3d as o3d\nfrom scipy.spatial import ConvexHull\n\nclass PlantMeshProcessor:\n    def __init__(self):\n        self.mesh = None\n        self.leaf_segments = []\n        self.stem_segments = []\n        \n    def process_point_cloud_to_mesh(self, point_cloud_path):\n        """Convert point cloud to mesh"""\n        # Load point cloud\n        pcd = o3d.io.read_point_cloud(point_cloud_path)\n        \n        # Point cloud preprocessing\n        pcd = self.preprocess_point_cloud(pcd)\n        \n        # Poisson reconstruction\n        mesh, _ = o3d.geometry.TriangleMesh.create_from_point_cloud_poisson(\n            pcd, depth=9, width=0, scale=1.1, linear_fit=False\n        )\n        \n        # Mesh post-processing\n        mesh = self.postprocess_mesh(mesh)\n        \n        self.mesh = mesh\n        return mesh\n    \n    def preprocess_point_cloud(self, pcd):\n        """Point cloud preprocessing"""\n        # Remove outliers\n        pcd, _ = pcd.remove_statistical_outlier(nb_neighbors=20, std_ratio=2.0)\n        \n        # Estimate normals\n        pcd.estimate_normals(\n            search_param=o3d.geometry.KDTreeSearchParamHybrid(radius=0.1, max_nn=30)\n        )\n        \n        # Orient normals consistently\n        pcd.orient_normals_consistent_tangent_plane(100)\n        \n        return pcd\n    \n    def postprocess_mesh(self, mesh):\n        """Mesh post-processing"""\n        # Remove duplicate vertices\n        mesh.remove_duplicated_vertices()\n        \n        # Remove duplicate triangles\n        mesh.remove_duplicated_triangles()\n        \n        # Remove degenerate triangles\n        mesh.remove_degenerate_triangles()\n        \n        # Remove non-manifold edges\n        mesh.remove_non_manifold_edges()\n        \n        # Smooth mesh\n        mesh = mesh.filter_smooth_simple(number_of_iterations=5)\n        \n        return mesh\n    \n    def segment_plant_organs(self, mesh):\n        """Plant organ segmentation"""\n        vertices = np.asarray(mesh.vertices)\n        faces = np.asarray(mesh.triangles)\n        \n        # Geometry-based segmentation\n        leaf_indices, stem_indices = self.geometric_segmentation(vertices, faces)\n        \n        # Create leaf and stem meshes\n        leaf_mesh = self.create_submesh(mesh, leaf_indices)\n        stem_mesh = self.create_submesh(mesh, stem_indices)\n        \n        self.leaf_segments = self.extract_individual_leaves(leaf_mesh)\n        self.stem_segments = [stem_mesh]\n        \n        return self.leaf_segments, self.stem_segments\n    \n    def geometric_segmentation(self, vertices, faces):\n        """Geometry-based segmentation"""\n        # Calculate vertex geometric features\n        curvatures = self.compute_curvature(vertices, faces)\n        normals = self.compute_normals(vertices, faces)\n        \n        # Classify based on curvature and normals\n        leaf_threshold = 0.5\n        leaf_indices = np.where(curvatures > leaf_threshold)[0]\n        stem_indices = np.where(curvatures <= leaf_threshold)[0]\n        \n        return leaf_indices, stem_indices\n    \n    def compute_curvature(self, vertices, faces):\n        """Calculate vertex curvature"""\n        # Simplified curvature calculation\n        mesh_trimesh = trimesh.Trimesh(vertices=vertices, faces=faces)\n        curvatures = trimesh.curvature.discrete_gaussian_curvature_measure(\n            mesh_trimesh, vertices, radius=0.05\n        )\n        return np.abs(curvatures)\n'})}),"\n",(0,i.jsx)(e.h2,{id:"step-5-canopy-construction-with-random-perturbation",children:"Step 5: Canopy Construction with Random Perturbation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class CanopyBuilder:\n    def __init__(self, plant_mesh, plant_segments):\n        self.base_plant = plant_mesh\n        self.leaf_segments = plant_segments[\'leaves\']\n        self.stem_segments = plant_segments[\'stems\']\n        self.canopy_plants = []\n        \n    def build_canopy(self, canopy_config):\n        """Build canopy structure"""\n        # Generate plant positions\n        positions = self.generate_plant_positions(canopy_config)\n        \n        # Create plant instance for each position\n        for i, pos in enumerate(positions):\n            plant_instance = self.create_plant_instance(pos, i)\n            self.canopy_plants.append(plant_instance)\n        \n        # Merge all plants\n        canopy_mesh = self.merge_plants()\n        \n        return canopy_mesh, self.canopy_plants\n    \n    def generate_plant_positions(self, config):\n        """Generate plant positions"""\n        row_spacing = config[\'row_spacing\']  # Row spacing\n        plant_spacing = config[\'plant_spacing\']  # Plant spacing\n        num_rows = config[\'num_rows\']\n        plants_per_row = config[\'plants_per_row\']\n        \n        positions = []\n        for row in range(num_rows):\n            for plant in range(plants_per_row):\n                x = plant * plant_spacing\n                y = row * row_spacing\n                z = 0  # Ground level\n                \n                # Add random perturbation\n                x += np.random.normal(0, plant_spacing * 0.1)\n                y += np.random.normal(0, row_spacing * 0.1)\n                \n                positions.append([x, y, z])\n        \n        return np.array(positions)\n    \n    def create_plant_instance(self, position, plant_id):\n        """Create individual plant instance"""\n        # Copy base plant\n        plant_mesh = self.base_plant.copy()\n        \n        # Apply random transformation\n        transform_matrix = self.generate_random_transform(position, plant_id)\n        plant_mesh.transform(transform_matrix)\n        \n        # Apply morphological variation\n        plant_mesh = self.apply_morphological_variation(plant_mesh, plant_id)\n        \n        return {\n            \'mesh\': plant_mesh,\n            \'position\': position,\n            \'id\': plant_id,\n            \'transform\': transform_matrix\n        }\n    \n    def generate_random_transform(self, position, plant_id):\n        """Generate random transformation matrix"""\n        # Set random seed for reproducibility\n        np.random.seed(plant_id)\n        \n        # Random rotation (mainly around Z-axis)\n        rotation_z = np.random.uniform(0, 2 * np.pi)\n        rotation_x = np.random.normal(0, 0.1)  # Slight tilt\n        rotation_y = np.random.normal(0, 0.1)\n        \n        # Random scaling\n        scale_factor = np.random.normal(1.0, 0.15)\n        scale_factor = np.clip(scale_factor, 0.7, 1.3)\n        \n        # Build transformation matrix\n        transform = np.eye(4)\n        \n        # Apply scaling\n        transform[:3, :3] *= scale_factor\n        \n        # Apply rotation\n        from scipy.spatial.transform import Rotation\n        rotation = Rotation.from_euler(\'xyz\', [rotation_x, rotation_y, rotation_z])\n        transform[:3, :3] = rotation.as_matrix() @ transform[:3, :3]\n        \n        # Apply translation\n        transform[:3, 3] = position\n        \n        return transform\n    \n    def apply_morphological_variation(self, mesh, plant_id):\n        """Apply morphological variation"""\n        vertices = np.asarray(mesh.vertices)\n        \n        # Leaf shape variation\n        leaf_variation = self.generate_leaf_variation(plant_id)\n        vertices = self.apply_leaf_deformation(vertices, leaf_variation)\n        \n        # Stem variation\n        stem_variation = self.generate_stem_variation(plant_id)\n        vertices = self.apply_stem_deformation(vertices, stem_variation)\n        \n        # Update mesh\n        mesh.vertices = o3d.utility.Vector3dVector(vertices)\n        mesh.compute_vertex_normals()\n        \n        return mesh\n    \n    def generate_leaf_variation(self, plant_id):\n        """Generate leaf variation parameters"""\n        np.random.seed(plant_id + 1000)\n        \n        return {\n            \'length_factor\': np.random.normal(1.0, 0.2),\n            \'width_factor\': np.random.normal(1.0, 0.15),\n            \'curvature_factor\': np.random.normal(1.0, 0.3),\n            \'angle_variation\': np.random.normal(0, 0.2)\n        }\n'})}),"\n",(0,i.jsx)(e.h2,{id:"step-6-ray-tracing-algorithm-implementation",children:"Step 6: Ray Tracing Algorithm Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"import numpy as np\nfrom numba import jit, cuda\nimport matplotlib.pyplot as plt\n\nclass RayTracingEngine:\n    def __init__(self, canopy_mesh, light_config):\n        self.canopy_mesh = canopy_mesh\n        self.light_config = light_config\n        self.acceleration_structure = None\n        self.build_acceleration_structure()\n        \n    def build_acceleration_structure(self):\n        \"\"\"Build acceleration structure (BVH tree)\"\"\"\n        from rtree import index\n        \n        # Create spatial index\n        idx = index.Index()\n        \n        faces = np.asarray(self.canopy_mesh.triangles)\n        vertices = np.asarray(self.canopy_mesh.vertices)\n        \n        for i, face in enumerate(faces):\n            # Calculate triangle bounding box\n            triangle_vertices = vertices[face]\n            min_coords = np.min(triangle_vertices, axis=0)\n            max_coords = np.max(triangle_vertices, axis=0)\n            \n            # Insert into spatial index\n            idx.insert(i, (*min_coords, *max_coords))\n        \n        self.acceleration_structure = idx\n        self.faces = faces\n        self.vertices = vertices\n    \n    def simulate_light_distribution(self, sun_angles, num_rays=1000000):\n        \"\"\"Simulate light distribution\"\"\"\n        results = {}\n        \n        for time_step, sun_angle in enumerate(sun_angles):\n            print(f\"Computing light distribution for time step {time_step}\")\n            \n            # Generate rays\n            rays = self.generate_sun_rays(sun_angle, num_rays)\n            \n            # Ray tracing\n            intersections = self.trace_rays(rays)\n            \n            # Calculate light intensity distribution\n            light_map = self.compute_light_intensity_map(intersections)\n            \n            results[time_step] = {\n                'sun_angle': sun_angle,\n                'light_map': light_map,\n                'intersections': intersections\n            }\n        \n        return results\n    \n    def generate_sun_rays(self, sun_angle, num_rays):\n        \"\"\"Generate sun rays\"\"\"\n        # Sun direction vector\n        elevation, azimuth = sun_angle\n        sun_direction = np.array([\n            np.cos(elevation) * np.sin(azimuth),\n            np.cos(elevation) * np.cos(azimuth),\n            -np.sin(elevation)  # Downward\n        ])\n        \n        # Generate parallel rays\n        # Create ray origin grid above canopy\n        canopy_bounds = self.get_canopy_bounds()\n        \n        # Extend bounds to ensure full canopy coverage\n        x_min, x_max = canopy_bounds[0] - 1, canopy_bounds[1] + 1\n        y_min, y_max = canopy_bounds[2] - 1, canopy_bounds[3] + 1\n        z_start = canopy_bounds[5] + 2  # 2m above canopy top\n        \n        # Generate random origins\n        origins = np.random.uniform(\n            [x_min, y_min, z_start],\n            [x_max, y_max, z_start],\n            (num_rays, 3)\n        )\n        \n        # All rays have same direction (parallel light)\n        directions = np.tile(sun_direction, (num_rays, 1))\n        \n        return {\n            'origins': origins,\n            'directions': directions\n        }\n    \n    @jit(nopython=True)\n    def ray_triangle_intersection(self, ray_origin, ray_direction, v0, v1, v2):\n        \"\"\"Ray-triangle intersection test (M\xf6ller-Trumbore algorithm)\"\"\"\n        epsilon = 1e-8\n        \n        edge1 = v1 - v0\n        edge2 = v2 - v0\n        h = np.cross(ray_direction, edge2)\n        a = np.dot(edge1, h)\n        \n        if abs(a) < epsilon:\n            return False, 0.0, 0.0, 0.0\n        \n        f = 1.0 / a\n        s = ray_origin - v0\n        u = f * np.dot(s, h)\n        \n        if u < 0.0 or u > 1.0:\n            return False, 0.0, 0.0, 0.0\n        \n        q = np.cross(s, edge1)\n        v = f * np.dot(ray_direction, q)\n        \n        if v < 0.0 or u + v > 1.0:\n            return False, 0.0, 0.0, 0.0\n        \n        t = f * np.dot(edge2, q)\n        \n        if t > epsilon:\n            return True, t, u, v\n        \n        return False, 0.0, 0.0, 0.0\n    \n    def trace_rays(self, rays):\n        \"\"\"Ray tracing\"\"\"\n        origins = rays['origins']\n        directions = rays['directions']\n        intersections = []\n        \n        for i in range(len(origins)):\n            ray_origin = origins[i]\n            ray_direction = directions[i]\n            \n            # Use spatial index to accelerate intersection tests\n            intersection = self.find_closest_intersection(ray_origin, ray_direction)\n            \n            if intersection is not None:\n                intersections.append({\n                    'ray_id': i,\n                    'point': intersection['point'],\n                    'normal': intersection['normal'],\n                    'face_id': intersection['face_id'],\n                    'distance': intersection['distance']\n                })\n        \n        return intersections\n    \n    def compute_light_intensity_map(self, intersections):\n        \"\"\"Calculate light intensity distribution map\"\"\"\n        # Create 3D grid\n        bounds = self.get_canopy_bounds()\n        resolution = 100\n        \n        x = np.linspace(bounds[0], bounds[1], resolution)\n        y = np.linspace(bounds[2], bounds[3], resolution)\n        z = np.linspace(bounds[4], bounds[5], resolution)\n        \n        light_intensity = np.zeros((resolution, resolution, resolution))\n        \n        # Map intersection points to grid\n        for intersection in intersections:\n            point = intersection['point']\n            \n            # Find corresponding grid indices\n            xi = int((point[0] - bounds[0]) / (bounds[1] - bounds[0]) * (resolution - 1))\n            yi = int((point[1] - bounds[2]) / (bounds[3] - bounds[2]) * (resolution - 1))\n            zi = int((point[2] - bounds[4]) / (bounds[5] - bounds[4]) * (resolution - 1))\n            \n            # Ensure indices are within valid range\n            xi = np.clip(xi, 0, resolution - 1)\n            yi = np.clip(yi, 0, resolution - 1)\n            zi = np.clip(zi, 0, resolution - 1)\n            \n            # Increase light intensity\n            light_intensity[xi, yi, zi] += 1\n        \n        return {\n            'intensity': light_intensity,\n            'bounds': bounds,\n            'resolution': resolution,\n            'coordinates': (x, y, z)\n        }\n"})}),"\n",(0,i.jsx)(e.h2,{id:"step-7-light-response-curve-model",children:"Step 7: Light Response Curve Model"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"class PhotosynthesisModel:\n    def __init__(self):\n        # Farquhar-von Caemmerer-Berry model parameters\n        self.vcmax25 = 60.0  # Maximum carboxylation rate at 25\xb0C (\u03bcmol m\u207b\xb2 s\u207b\xb9)\n        self.jmax25 = 120.0  # Maximum electron transport rate at 25\xb0C (\u03bcmol m\u207b\xb2 s\u207b\xb9)\n        self.rd25 = 1.5      # Dark respiration rate at 25\xb0C (\u03bcmol m\u207b\xb2 s\u207b\xb9)\n        \n        # Temperature response parameters\n        self.ha_vcmax = 65330.0  # Vcmax activation energy (J mol\u207b\xb9)\n        self.ha_jmax = 43540.0   # Jmax activation energy (J mol\u207b\xb9)\n        self.ha_rd = 46390.0     # Rd activation energy (J mol\u207b\xb9)\n        \n        # Other parameters\n        self.kc25 = 404.9    # CO2 Michaelis constant at 25\xb0C (\u03bcmol mol\u207b\xb9)\n        self.ko25 = 278.4    # O2 Michaelis constant at 25\xb0C (mmol mol\u207b\xb9)\n        self.cp25 = 42.75    # CO2 compensation point at 25\xb0C (\u03bcmol mol\u207b\xb9)\n        \n        self.r_gas = 8.314   # Gas constant (J mol\u207b\xb9 K\u207b\xb9)\n        \n    def compute_photosynthesis_rate(self, light_intensity, temperature, co2_conc, leaf_area):\n        \"\"\"Calculate photosynthesis rate\"\"\"\n        # Temperature correction\n        vcmax = self.temperature_correction(self.vcmax25, self.ha_vcmax, temperature)\n        jmax = self.temperature_correction(self.jmax25, self.ha_jmax, temperature)\n        rd = self.temperature_correction(self.rd25, self.ha_rd, temperature)\n        \n        # Temperature correction for Michaelis constants\n        kc = self.temperature_correction(self.kc25, 79430.0, temperature)\n        ko = self.temperature_correction(self.ko25, 36380.0, temperature)\n        cp = self.temperature_correction(self.cp25, 37830.0, temperature)\n        \n        # Calculate electron transport rate\n        j = self.compute_electron_transport_rate(light_intensity, jmax)\n        \n        # Calculate RuBisCO-limited photosynthesis rate\n        wc = (vcmax * (co2_conc - cp)) / (co2_conc + kc * (1 + 210 / ko))\n        \n        # Calculate RuBP regeneration-limited photosynthesis rate\n        wj = (j * (co2_conc - cp)) / (4 * (co2_conc + 2 * cp))\n        \n        # Take minimum (limiting factor)\n        gross_photosynthesis = min(wc, wj)\n        \n        # Net photosynthesis rate\n        net_photosynthesis = gross_photosynthesis - rd\n        \n        # Multiply by leaf area to get total photosynthesis rate\n        total_rate = net_photosynthesis * leaf_area\n        \n        return {\n            'net_rate': net_photosynthesis,\n            'total_rate': total_rate,\n            'gross_rate': gross_photosynthesis,\n            'respiration': rd,\n            'electron_transport': j,\n            'rubisco_limited': wc,\n            'rubp_limited': wj\n        }\n    \n    def temperature_correction(self, rate25, activation_energy, temperature):\n        \"\"\"Temperature correction function\"\"\"\n        temp_k = temperature + 273.15\n        temp25_k = 25.0 + 273.15\n        \n        return rate25 * np.exp(activation_energy * (temp_k - temp25_k) / (self.r_gas * temp_k * temp25_k))\n    \n    def compute_electron_transport_rate(self, light_intensity, jmax):\n        \"\"\"Calculate electron transport rate\"\"\"\n        # Light response curve parameters\n        alpha = 0.24  # Quantum efficiency\n        theta = 0.7   # Curvature factor\n        \n        # Non-rectangular hyperbola model\n        a = theta\n        b = -(alpha * light_intensity + jmax)\n        c = alpha * light_intensity * jmax\n        \n        # Solve quadratic equation\n        discriminant = b**2 - 4*a*c\n        if discriminant >= 0:\n            j = (-b - np.sqrt(discriminant)) / (2*a)\n        else:\n            j = 0\n        \n        return max(0, j)\n    \n    def compute_canopy_photosynthesis(self, light_distribution, leaf_area_distribution, \n                                    temperature_map, co2_concentration=400):\n        \"\"\"Calculate canopy photosynthesis rate\"\"\"\n        total_photosynthesis = 0\n        detailed_results = []\n        \n        # Get light distribution data\n        light_intensity = light_distribution['intensity']\n        coordinates = light_distribution['coordinates']\n        \n        # Iterate through each voxel\n        for i in range(light_intensity.shape[0]):\n            for j in range(light_intensity.shape[1]):\n                for k in range(light_intensity.shape[2]):\n                    if light_intensity[i, j, k] > 0:\n                        # Get parameters for this voxel\n                        x, y, z = coordinates[0][i], coordinates[1][j], coordinates[2][k]\n                        light = light_intensity[i, j, k]\n                        leaf_area = leaf_area_distribution.get((i, j, k), 0)\n                        temperature = temperature_map.get((i, j, k), 25.0)\n                        \n                        if leaf_area > 0:\n                            # Calculate photosynthesis rate for this voxel\n                            result = self.compute_photosynthesis_rate(\n                                light, temperature, co2_concentration, leaf_area\n                            )\n                            \n                            total_photosynthesis += result['total_rate']\n                            \n                            detailed_results.append({\n                                'position': (x, y, z),\n                                'voxel_index': (i, j, k),\n                                'light_intensity': light,\n                                'leaf_area': leaf_area,\n                                'temperature': temperature,\n                                'photosynthesis_rate': result['total_rate'],\n                                'details': result\n                            })\n        \n        return {\n            'total_canopy_photosynthesis': total_photosynthesis,\n            'voxel_results': detailed_results,\n            'average_rate': total_photosynthesis / len(detailed_results) if detailed_results else 0\n        }\n"})}),"\n",(0,i.jsx)(e.h2,{id:"step-8-complete-workflow-integration",children:"Step 8: Complete Workflow Integration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"class CanopyPhotosynthesisSimulator:\n    def __init__(self):\n        self.capture_system = None\n        self.reconstruction_engine = None\n        self.mesh_processor = None\n        self.canopy_builder = None\n        self.ray_tracer = None\n        self.photosynthesis_model = None\n        \n    def run_complete_simulation(self, config):\n        \"\"\"Run complete canopy photosynthesis simulation\"\"\"\n        print(\"Starting canopy photosynthesis simulation...\")\n        \n        # 1. Image capture\n        print(\"Step 1: Multi-view image capture\")\n        if config['use_existing_images']:\n            image_dir = config['image_directory']\n        else:\n            image_dir = self.capture_multi_view_images(config['capture_config'])\n        \n        # 2. 3D reconstruction\n        print(\"Step 2: 3D reconstruction\")\n        if config['reconstruction_method'] == 'sfm':\n            point_cloud = self.run_sfm_reconstruction(image_dir)\n        elif config['reconstruction_method'] == '3dgs':\n            point_cloud = self.run_3dgs_reconstruction(image_dir)\n        else:\n            raise ValueError(\"Unsupported reconstruction method\")\n        \n        # 3. Mesh generation\n        print(\"Step 3: Mesh generation\")\n        plant_mesh = self.generate_plant_mesh(point_cloud)\n        \n        # 4. Organ segmentation\n        print(\"Step 4: Organ segmentation\")\n        plant_segments = self.segment_plant_organs(plant_mesh)\n        \n        # 5. Canopy construction\n        print(\"Step 5: Canopy construction\")\n        canopy_mesh, canopy_plants = self.build_canopy(plant_mesh, plant_segments, config['canopy_config'])\n        \n        # 6. Ray tracing\n        print(\"Step 6: Ray tracing simulation\")\n        light_distribution = self.simulate_light_distribution(canopy_mesh, config['light_config'])\n        \n        # 7. Photosynthesis calculation\n        print(\"Step 7: Photosynthesis calculation\")\n        photosynthesis_results = self.calculate_canopy_photosynthesis(\n            light_distribution, canopy_plants, config['environmental_config']\n        )\n        \n        # 8. Results analysis and visualization\n        print(\"Step 8: Results analysis and visualization\")\n        self.analyze_and_visualize_results(photosynthesis_results, config['output_dir'])\n        \n        return photosynthesis_results\n    \n    def analyze_and_visualize_results(self, results, output_dir):\n        \"\"\"Analyze and visualize results\"\"\"\n        import matplotlib.pyplot as plt\n        from mpl_toolkits.mplot3d import Axes3D\n        \n        # Create output directory\n        os.makedirs(output_dir, exist_ok=True)\n        \n        # 1. Photosynthesis rate distribution plot\n        self.plot_photosynthesis_distribution(results, output_dir)\n        \n        # 2. Light distribution visualization\n        self.plot_light_distribution(results, output_dir)\n        \n        # 3. Statistical analysis\n        self.generate_statistical_report(results, output_dir)\n        \n        # 4. 3D visualization\n        self.create_3d_visualization(results, output_dir)\n    \n    def generate_statistical_report(self, results, output_dir):\n        \"\"\"Generate statistical report\"\"\"\n        report = {\n            'total_canopy_photosynthesis': results['total_canopy_photosynthesis'],\n            'average_rate': results['average_rate'],\n            'num_active_voxels': len(results['voxel_results']),\n            'statistics': {}\n        }\n        \n        if results['voxel_results']:\n            rates = [r['photosynthesis_rate'] for r in results['voxel_results']]\n            light_intensities = [r['light_intensity'] for r in results['voxel_results']]\n            \n            report['statistics'] = {\n                'photosynthesis_rate': {\n                    'mean': np.mean(rates),\n                    'std': np.std(rates),\n                    'min': np.min(rates),\n                    'max': np.max(rates),\n                    'median': np.median(rates)\n                },\n                'light_intensity': {\n                    'mean': np.mean(light_intensities),\n                    'std': np.std(light_intensities),\n                    'min': np.min(light_intensities),\n                    'max': np.max(light_intensities),\n                    'median': np.median(light_intensities)\n                }\n            }\n        \n        # Save report\n        with open(os.path.join(output_dir, 'simulation_report.json'), 'w') as f:\n            json.dump(report, f, indent=2)\n        \n        # Generate text report\n        with open(os.path.join(output_dir, 'simulation_report.txt'), 'w') as f:\n            f.write(\"Canopy Photosynthesis Simulation Report\\n\")\n            f.write(\"=\" * 40 + \"\\n\\n\")\n            f.write(f\"Total Canopy Photosynthesis: {report['total_canopy_photosynthesis']:.2f} \u03bcmol s\u207b\xb9\\n\")\n            f.write(f\"Average Rate: {report['average_rate']:.2f} \u03bcmol m\u207b\xb2 s\u207b\xb9\\n\")\n            f.write(f\"Number of Active Voxels: {report['num_active_voxels']}\\n\\n\")\n            \n            if 'photosynthesis_rate' in report['statistics']:\n                stats = report['statistics']['photosynthesis_rate']\n                f.write(\"Photosynthesis Rate Statistics:\\n\")\n                f.write(f\"  Mean: {stats['mean']:.2f} \u03bcmol m\u207b\xb2 s\u207b\xb9\\n\")\n                f.write(f\"  Std:  {stats['std']:.2f} \u03bcmol m\u207b\xb2 s\u207b\xb9\\n\")\n                f.write(f\"  Min:  {stats['min']:.2f} \u03bcmol m\u207b\xb2 s\u207b\xb9\\n\")\n                f.write(f\"  Max:  {stats['max']:.2f} \u03bcmol m\u207b\xb2 s\u207b\xb9\\n\")\n\n# Usage example\ndef main():\n    # Configuration parameters\n    config = {\n        'use_existing_images': True,\n        'image_directory': './plant_images',\n        'reconstruction_method': 'sfm',  # 'sfm' or '3dgs'\n        'canopy_config': {\n            'row_spacing': 0.75,\n            'plant_spacing': 0.25,\n            'num_rows': 5,\n            'plants_per_row': 10\n        },\n        'light_config': {\n            'sun_angles': [(60, 180), (45, 180), (30, 180)],  # (elevation, azimuth)\n            'num_rays': 100000\n        },\n        'environmental_config': {\n            'temperature': 25.0,\n            'co2_concentration': 400.0,\n            'humidity': 0.6\n        },\n        'output_dir': './simulation_results'\n    }\n    \n    # Run simulation\n    simulator = CanopyPhotosynthesisSimulator()\n    results = simulator.run_complete_simulation(config)\n    \n    print(f\"Simulation completed. Total canopy photosynthesis: {results['total_canopy_photosynthesis']:.2f} \u03bcmol s\u207b\xb9\")\n\nif __name__ == \"__main__\":\n    main()\n"})}),"\n",(0,i.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(e.p,{children:"This comprehensive tutorial presents a complete workflow for canopy photosynthesis modeling based on 3D reconstruction, including:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Multi-view Image Capture"}),": Spherical capture strategy and quality control"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"3D Reconstruction"}),": Both SfM and 3D Gaussian Splatting methods"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Mesh Processing"}),": Point cloud to mesh conversion and organ segmentation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Canopy Construction"}),": Plant replication with random perturbation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Ray Tracing"}),": Efficient light distribution simulation algorithms"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Photosynthesis Calculation"}),": Farquhar model-based photosynthesis rate computation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Results Analysis"}),": Statistical analysis and visualization"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"This system provides powerful tools for precision agriculture, plant breeding, and ecological research, helping researchers understand canopy photosynthetic characteristics and optimize cultivation management strategies."}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.em,{children:"Last updated: September 2025"})})]})}function m(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(p,{...n})}):p(n)}},6481:n=>{n.exports=JSON.parse('{"permalink":"/blog/canopy-photosynthesis-modeling-en","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-09-20-canopy-photosynthesis-modeling.md","source":"@site/blog/2023-09-20-canopy-photosynthesis-modeling.md","title":"Canopy Photosynthesis Modeling Tutorial Based on 3D Reconstruction","description":"Introduction","date":"2023-09-20T00:00:00.000Z","tags":[{"inline":false,"label":"Plant Phenotyping","permalink":"/blog/tags/plant-phenotyping","description":"Automated plant trait analysis"},{"inline":false,"label":"3D Reconstruction","permalink":"/blog/tags/3d-reconstruction-alt","description":"3D model reconstruction technology"},{"inline":false,"label":"Photosynthesis","permalink":"/blog/tags/photosynthesis","description":"Photosynthesis modeling and simulation"},{"inline":false,"label":"Computer Vision","permalink":"/blog/tags/computer-vision","description":"Computer vision and image processing"},{"inline":false,"label":"Ray Tracing","permalink":"/blog/tags/ray-tracing","description":"Ray tracing algorithms and light simulation"}],"readingTime":15.77,"hasTruncateMarker":true,"authors":[{"name":"Liangchao Deng","title":"PhD @ SHZU","url":"https://github.com/smiler488","page":{"permalink":"/blog/authors/liangchao"},"socials":{"x":"https://x.com/smiler488","github":"https://github.com/smiler488"},"imageURL":"https://github.com/smiler488.png","key":"liangchao"}],"frontMatter":{"slug":"canopy-photosynthesis-modeling-en","title":"Canopy Photosynthesis Modeling Tutorial Based on 3D Reconstruction","authors":["liangchao"],"tags":["plant phenotyping","3d reconstruction","photosynthesis","computer vision","ray tracing"]},"unlisted":false,"prevItem":{"title":"Guide to Local LLM Deployment, Training and Fine-tuning","permalink":"/blog/local-llm-training-guide-en"},"nextItem":{"title":"Complete PyTorch Tutorial for Machine Learning and Deep Learning","permalink":"/blog/pytorch-ml-dl-tutorial"}}')},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>r});var s=t(6540);const i={},a=s.createContext(i);function o(n){const e=s.useContext(a);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:o(n.components),s.createElement(a.Provider,{value:e},n.children)}}}]);