"use strict";(self.webpackChunkliangchao_website=self.webpackChunkliangchao_website||[]).push([[6815],{5514:(e,t,n)=>{n.r(t),n.d(t,{default:()=>o});var i=n(6540),a=n(1656),r=n(5260),s=n(4848);function o(){const e=(0,i.useRef)(null),t=(0,i.useRef)(null),n=(0,i.useRef)(null),[o,d]=(0,i.useState)("Waiting for image..."),[h,u]=(0,i.useState)(!1),[m,g]=(0,i.useState)(!1),[p,x]=(0,i.useState)([]),[w,f]=(0,i.useState)(""),y=(0,i.useRef)(null),j=(0,i.useRef)(null),v=(0,i.useRef)(null),M=(e,t)=>{d(e||"");const n=document.querySelector(".status-bar");n&&(n.classList.remove("info","warning","error","processing"),!0===t?n.classList.add("processing"):"string"==typeof t&&n.classList.add(t))};(0,i.useEffect)((()=>{const e=["/js/opencv.js"];let t=null,n=0,i=null,a=null;const r=()=>{if(n>=e.length)return f((e=>e+"\nAll OpenCV script sources failed to load")),void M("Failed to load OpenCV.js from all sources","error");const i=e[n++];f((e=>e+`\nLoading OpenCV from: ${i}`));try{delete window.Module?.locateFile}catch{}window.Module||(window.Module={}),t=((e,t,n)=>{const i=document.createElement("script");return i.src=e,i.async=!0,i.crossOrigin="anonymous",i.onload=t,i.onerror=n,document.head.appendChild(i),i})(i,(()=>{f((e=>e+"\nOpenCV script loaded, waiting for initialization"))}),(e=>{f((e=>e+`\nFailed to load: ${i}`)),console.error("OpenCV script failed to load",e),M("Failed to load OpenCV.js","error")}))};if("undefined"!=typeof window&&window.cv&&window.cv.Mat){let e=!0;try{(new window.cv.Mat).delete()}catch{e=!1}return e?(g(!0),M("OpenCV loaded. Ready to process."),void f((e=>e+"\nDetected existing OpenCV with valid cv.Mat"))):(f((e=>e+"\nExisting OpenCV is incompatible (cv.Mat not constructible); switching to next candidate")),void r())}M("Waiting for OpenCV to load...",!0),f("Start loading OpenCV.js"),i=setTimeout((()=>{window.cv||(f((e=>e+"\nOpenCV load timed out")),M("OpenCV.js load timed out","warning"),f((e=>e+"\nTip: If you use a local build, ensure both /js/opencv.js and /js/opencv_js.wasm exist. If you use the bootstrapper, make sure CDN access is allowed.")))}),12e3),window.Module=window.Module||{};const s=window.Module.onRuntimeInitialized;return window.Module.onRuntimeInitialized=()=>{clearTimeout(i);try{if(!window.cv||!window.cv.Mat)throw new Error("cv.Mat missing");let t=!0;try{(new window.cv.Mat).delete()}catch(e){t=!1}if(!t)return f((e=>e+"\nIncompatible OpenCV build detected (cv.Mat is not a usable constructor).")),void r();g(!0),f((e=>e+"\nOpenCV initialization complete")),M("OpenCV loaded successfully"),s&&s()}catch(e){f((e=>e+"\nOpenCV initialization verification failed, switching to next candidate")),r()}},r(),a=setInterval((()=>{try{if(window.cv&&"function"==typeof window.cv.Mat){let e=!0;try{(new window.cv.Mat).delete()}catch{e=!1}e&&!m&&(clearInterval(a),a=null,clearTimeout(i),g(!0),M("OpenCV loaded. Ready to process."),f((e=>e+"\nOpenCV detected via polling")))}}catch{}}),500),()=>{try{t&&document.head.removeChild(t)}catch{}a&&clearInterval(a),clearTimeout(i)}}),[]),(0,i.useEffect)((()=>{const n=e.current;!n||n.width&&n.height||(n.width=800,n.height=600);const i=t.current;i&&(i.width=n?.width||800,i.height=n?.height||600,i.style.width=`${i.width}px`,i.style.height=`${i.height}px`)}),[]);const C=(e,t)=>{const n=t&&(t.message||t.toString())||"Unknown error";console.error(e,t),f((t=>`${t}\n${e}: ${n}`)),M(`${e}: ${n}`,"error")};function R(e,t,n,i,a){if(!i||"none"===i||!a)return{scaleMMPerPx:0,refMask:null};f((e=>`${e}\nCompute scale: ${i}, ${a} mm, ROI: ${n.width}x${n.height}`));const r=t.roi(n),s=new e.Mat;e.cvtColor(r,s,e.COLOR_RGBA2GRAY),e.GaussianBlur(s,s,new e.Size(5,5),0);let o=0,l=null;if("coin"===i){const i=new e.Mat;try{if("function"==typeof e.HoughCircles)if(f((e=>e+"\nTry HoughCircles for circle detection")),e.HoughCircles(s,i,e.HOUGH_GRADIENT,1.2,Math.max(8,s.rows/8),100,30,0,0),i.rows>0&&i.data32F&&i.data32F.length>=3){const r=i.data32F[0],s=i.data32F[1],c=i.data32F[2],d=Math.max(1,2*c);o=a/d,l=e.Mat.zeros(t.rows,t.cols,e.CV_8UC1);const h=new e.Point(n.x+r,n.y+s);e.circle(l,h,Math.round(c+2),new e.Scalar(255),-1),f((e=>`${e}\nHoughCircles detected circle: radius ${c.toFixed(1)} px, diameter ${d.toFixed(1)} px`))}else f((e=>e+"\nHoughCircles found no circle"))}catch(c){f((e=>`${e}\nHoughCircles failed: ${c.message}`)),console.warn("HoughCircles unavailable or failed:",c)}if(i.delete(),!o){f((e=>e+"\nTry contour-based circle detection"));const i=new e.Mat;e.Canny(s,i,80,160);const r=new e.MatVector,c=new e.Mat;e.findContours(i,r,c,e.RETR_EXTERNAL,e.CHAIN_APPROX_SIMPLE);let d=-1,h=0,u=0,m=null;for(let t=0;t<r.size();t++){const n=r.get(t),i=e.contourArea(n);if(i>h&&i>50){const a=e.boundingRect(n),r=Math.max(a.width,a.height)/2;h=i,d=t,u=r,m={x:a.x+a.width/2,y:a.y+a.height/2}}n.delete()}if(d>=0&&u>0){const i=2*u;o=a/i,l=e.Mat.zeros(t.rows,t.cols,e.CV_8UC1);const r=new e.Point(n.x+m.x,n.y+m.y);e.circle(l,r,Math.round(u+2),new e.Scalar(255),-1),f((e=>`${e}\nContour-based circle detected: radius ${u.toFixed(1)} px, diameter ${i.toFixed(1)} px`))}else f((e=>e+"\nContour-based circle not found"));i.delete(),r.delete(),c.delete()}}else if("square"===i){f((e=>e+"\nTry detecting square reference"));const i=new e.Mat;e.threshold(s,i,0,255,e.THRESH_BINARY+e.THRESH_OTSU);const r=new e.MatVector,c=new e.Mat;e.findContours(i,r,c,e.RETR_EXTERNAL,e.CHAIN_APPROX_SIMPLE);let d=0,h=0,u=null;for(let t=0;t<r.size();t++){const n=r.get(t),i=e.boundingRect(n),a=i.width*i.height;a>d*h&&a>100&&(d=i.width,h=i.height,u=i),n.delete()}if(u){const i=Math.max(u.width,u.height);o=a/i,l=e.Mat.zeros(t.rows,t.cols,e.CV_8UC1);const r=new e.Rect(n.x+u.x,n.y+u.y,u.width,u.height);e.rectangle(l,new e.Point(r.x,r.y),new e.Point(r.x+r.width,r.y+r.height),new e.Scalar(255),-1),f((e=>`${e}\nDetected square: ${u.width}x${u.height} px, side ${i} px`))}else f((e=>e+"\nNo square reference detected"));i.delete(),r.delete(),c.delete()}return r.delete(),s.delete(),{scaleMMPerPx:o,refMask:l}}const[b,N]=(0,i.useState)(!1);return(0,s.jsxs)(a.A,{title:"Image Quantification",children:[(0,s.jsx)(r.A,{children:(0,s.jsx)("meta",{name:"viewport",content:"width=device-width, initial-scale=1"})}),(0,s.jsxs)("div",{className:"container",children:[(0,s.jsx)("h1",{className:"title",children:"Image Quantification Tool"}),(0,s.jsx)("p",{className:"description",children:"Capture or upload an image, set a reference object (coin or square card), and quantify samples: count, geometry (length/width/area/perimeter), and color statistics."}),(0,s.jsx)("div",{className:"status-bar "+(h?"processing":""),children:(0,s.jsxs)("div",{className:"status-message",children:[h&&(0,s.jsx)("div",{className:"spinner"}),o]})}),(0,s.jsx)("div",{style:{textAlign:"right",marginBottom:"10px"},children:(0,s.jsx)("button",{onClick:()=>N(!b),className:"btn btn-ghost",style:{fontSize:"12px"},children:b?"Hide debug info":"Show debug info"})}),b&&(0,s.jsx)("div",{className:"debug-panel",children:(0,s.jsx)(l,{title:"Debug Info",children:(0,s.jsx)("div",{style:{maxHeight:"200px",overflow:"auto",fontFamily:"monospace",fontSize:"12px",whiteSpace:"pre-wrap"},children:w||"No debug info yet"})})}),(0,s.jsxs)("div",{className:"controls-grid",children:[(0,s.jsxs)("div",{className:"input-group",children:[(0,s.jsx)("label",{htmlFor:"imageNumber",className:"input-label",children:"Image ID"}),(0,s.jsx)("input",{id:"imageNumber",ref:y,type:"text",placeholder:"e.g., LeafSet-001",className:"input-field"})]}),(0,s.jsxs)("div",{className:"input-group",children:[(0,s.jsx)("label",{htmlFor:"refType",className:"input-label",children:"Reference"}),(0,s.jsxs)("select",{id:"refType",ref:j,defaultValue:"coin",className:"select-field",children:[(0,s.jsx)("option",{value:"coin",children:"Coin (circle)"}),(0,s.jsx)("option",{value:"square",children:"Square card"}),(0,s.jsx)("option",{value:"none",children:"No reference"})]})]}),(0,s.jsxs)("div",{className:"input-group",children:[(0,s.jsx)("label",{htmlFor:"refSizeMM",className:"input-label",children:"Known size (mm)"}),(0,s.jsx)("input",{id:"refSizeMM",ref:v,type:"number",inputMode:"decimal",step:"0.1",placeholder:"e.g., 25.0",className:"input-field",defaultValue:"25.0"}),(0,s.jsx)("small",{className:"input-help",children:"Coin: diameter (mm), Square: side length (mm)"})]}),(0,s.jsxs)("div",{className:"input-group",children:[(0,s.jsx)("label",{htmlFor:"photoInput",className:"input-label",children:"Capture / Upload"}),(0,s.jsxs)("div",{className:"file-input-container",children:[(0,s.jsx)("label",{htmlFor:"photoInput",className:"file-input-label",children:"Choose Image"}),(0,s.jsx)("input",{id:"photoInput",ref:n,type:"file",accept:"image/*",capture:"environment",className:"file-input",onChange:n=>{const i=n?.target?.files?.[0];if(!i)return void M("No image selected.","warning");M("Loading image...",!0),f("Start loading image");const a=new FileReader;a.onload=n=>{const i=new Image;i.onload=()=>{f((e=>e+"\nImage loaded successfully")),function(n){const i=e.current;if(!i)return;i.width&&i.height||(i.width=800,i.height=600);const a=i.getContext("2d");a.clearRect(0,0,i.width,i.height);const r=Math.min(i.width/n.width,i.height/n.height),s=Math.max(1,Math.floor(n.width*r)),o=Math.max(1,Math.floor(n.height*r));a.drawImage(n,0,0,s,o);const l=t.current;if(l){l.width=i.width,l.height=i.height,l.style.width=`${l.width}px`,l.style.height=`${l.height}px`;l.getContext("2d").clearRect(0,0,l.width,l.height)}}(i),M("Image loaded. Click 'Process Image' to analyze.","info")},i.onerror=()=>{f((e=>e+"\nImage load failed")),M("Image load failed","error")},i.src=n.target.result},a.onerror=()=>{f((e=>e+"\nFile read failed")),M("File read failed","error")},a.readAsDataURL(i)}})]})]})]}),(0,s.jsxs)("div",{className:"button-group",children:[(0,s.jsx)("button",{id:"processBtn",type:"button",disabled:h||!m,className:"btn btn-primary",title:"Run detection, geometry and color quantification",onClick:async()=>{if(!m)return M("OpenCV not ready","warning"),void f((e=>e+"\nOpenCV not ready, cannot process"));const n=e.current;if(!n||!n.width||!n.height)return M("No valid image. Please capture or upload an image first.","warning"),void f((e=>e+"\nNo valid image"));u(!0),M("Processing image...",!0),f("Start processing image");const i=window.cv;let a=null,r=null,s=null,o=null,l=null,c=null,d=null,h=null,g=null;try{try{if(f((e=>e+"\nReading image data")),"function"==typeof i.imread)a=i.imread(n);else{const e=n.getContext("2d").getImageData(0,0,n.width,n.height);"function"==typeof i.matFromImageData?a=i.matFromImageData(e):(a=new i.Mat(n.height,n.width,i.CV_8UC4),a.data.set(new Uint8Array(e.data.buffer)))}if(!a||a.empty())throw new Error("Failed to read image from canvas - source is empty");r=new i.Mat,i.cvtColor(a,r,i.COLOR_RGBA2BGR),s=new i.Mat,i.cvtColor(r,s,i.COLOR_BGR2HSV),o=a.clone(),f((e=>e+"\nImage preprocessing done"))}catch(p){throw C("Failed to read from canvas",p),p}let e=0,u=null;try{f((e=>e+"\nStart computing scale"));const t=j.current?.value||"coin",n=parseFloat(v.current?.value||"0")||0;f((e=>`${e}\nReference: type=${t}, size=${n} mm`));const r=new i.Rect(0,0,Math.floor(.4*a.cols),Math.floor(.4*a.rows));let s=R(i,a,r,t,n);if(e=s.scaleMMPerPx,u=s.refMask,!e){f((e=>e+"\nNo reference found in corner ROI, trying full image"));const r=new i.Rect(0,0,a.cols,a.rows),s=R(i,a,r,t,n);if(s.scaleMMPerPx){if(e=s.scaleMMPerPx,u)try{u.delete()}catch{}u=s.refMask}}e?(f((t=>`${t}\nReference detected. Scale: ${e.toFixed(4)} mm/px`)),M(`Reference detected. Scale: ${e.toFixed(4)} mm/px`,"info")):(f((e=>e+"\nWarning: No reference detected, using pixel units")),M("Warning: No reference object detected. Using pixel units.","warning"))}catch(p){C("Scale estimation failed",p)}try{f((e=>e+"\nStart segmentation")),({binary:d,gray:h,blur:g}=function(e,t,n){const i=new e.Mat;e.cvtColor(t,i,e.COLOR_RGBA2GRAY);const a=new e.Mat;e.GaussianBlur(i,a,new e.Size(5,5),0);const r=new e.Mat,s=new e.Mat;if(e.threshold(a,r,0,255,e.THRESH_BINARY+e.THRESH_OTSU),e.threshold(a,s,0,255,e.THRESH_BINARY_INV+e.THRESH_OTSU),n){const t=new e.Mat;e.bitwise_not(n,t),e.bitwise_and(r,t,r),e.bitwise_and(s,t,s),t.delete()}const o=e.countNonZero(r),l=e.countNonZero(s);f((e=>`${e}\nBinarization stats: foreground ${o} px, inverse ${l} px`));let c=l>o?s:r;c!==r&&r.delete();c!==s&&s.delete();if(!c||c.empty()){f((e=>e+"\nBinary image empty, creating empty matrix"));const n=e.Mat.zeros(t.rows,t.cols,e.CV_8UC1);if(c&&c!==r&&c!==s)try{c.delete()}catch{}c=n}const d=e.Mat.ones(3,3,e.CV_8U);return e.morphologyEx(c,c,e.MORPH_OPEN,d),e.morphologyEx(c,c,e.MORPH_CLOSE,d),d.delete(),{binary:c,gray:i,blur:a}}(i,a,u)),f((e=>`${e}\nSegmentation done, binary non-zero pixels: ${i.countNonZero(d)}`))}catch(p){throw C("Segmentation failed",p),p}finally{if(u)try{u.delete()}catch{}}try{f((e=>e+"\nStart finding contours")),l=new i.MatVector,c=new i.Mat,d&&!d.empty()||(f((e=>e+"\nBinary image empty, creating empty mask")),d=i.Mat.zeros(a.rows,a.cols,i.CV_8UC1)),i.findContours(d,l,c,i.RETR_EXTERNAL,i.CHAIN_APPROX_SIMPLE),f((e=>`${e}\nFound ${l.size()} contours`))}catch(p){throw C("Finding contours failed",p),p}let m=[];try{f((e=>e+"\nStart processing contours"));const t=(y.current?.value||"IMG").trim()||"IMG";m=function(e,t,n,i,a,r,s,o){const l=Math.max(1,Math.round(n.rows*n.cols/8e5)),c=80*l,d=[],h=new e.Scalar(40,200,40,255);f((e=>`${e}\nProcess contours: ${t.size()} contours, min area: ${c} px`));for(let u=0;u<t.size();u++){const n=t.get(u),l=e.contourArea(n);if(l<c){n.delete();continue}const m=e.boundingRect(n),g=e.arcLength(n,!0);let p=e.Mat.zeros(i.rows,i.cols,e.CV_8UC1);e.drawContours(p,t,u,new e.Scalar(255,255,255,255),-1);const x=e.Mat.ones(3,3,e.CV_8U);e.erode(p,p,x),x.delete();const w=e.mean(i,p),f=e.mean(a,p),y=Math.max(m.width,m.height),j=Math.min(m.width,m.height),v=e=>s?e*s:e,M=s?l*s*s:l,C=v(g),R=v(y),b=v(j),N=y/Math.max(1,j),S=s?"mm":"px",$=s?"mm^2":"px^2";d.push({id:`${o}-A${u+1}`,length:R,width:b,area:M,perimeter:C,aspect:N,meanB:w[0],meanG:w[1],meanR:w[2],meanH:f[0],meanS:f[1],meanV:f[2],unit:S,areaUnit:$}),e.rectangle(r,new e.Point(m.x,m.y),new e.Point(m.x+m.width,m.y+m.height),h,2),e.putText(r,`${u+1}`,new e.Point(m.x,Math.max(0,m.y-5)),e.FONT_HERSHEY_SIMPLEX,.5,h,1),n.delete(),p.delete()}return f((e=>`${e}\nContour processing complete: ${d.length} valid samples`)),d}(i,l||new i.MatVector,a,r,s,o||a,e,t),x((e=>[...e,...m])),f((e=>`${e}\nProcessed ${m.length} samples`))}catch(p){C("Processing contours failed",p)}try{f((e=>e+"\nStart rendering results"));const e=t.current;if(e)if(o&&!o.empty()){if("function"==typeof i.imshow)i.imshow(e,o);else{const t=new i.Mat;try{i.cvtColor(o,t,i.COLOR_RGBA2RGBA)}catch(w){t.delete?.()}const n=new Uint8ClampedArray(t.data&&t.data.length?t.data:o.data),a=new ImageData(n,o.cols,o.rows);e.getContext("2d").putImageData(a,0,0),t.delete?.()}f((e=>e+"\nRendering complete"))}else{f((e=>e+"\nVisualization matrix empty, using original image as fallback"));const t=e.getContext("2d");t.clearRect(0,0,e.width,e.height),t.drawImage(n,0,0)}}catch(p){C("Rendering results failed",p)}M(`Done. Detected ${m&&m.length||0} samples.`,"info"),f((e=>`${e}\nProcessing finished, detected ${m.length} samples`))}catch(b){f((e=>`${e}\nUnhandled error during processing: ${b.message}`)),console.error("Unhandled error in processing:",b),M("Processing error: "+(b.message||b),"error")}finally{u(!1);try{a?.delete?.()}catch{}try{r?.delete?.()}catch{}try{s?.delete?.()}catch{}try{o?.delete?.()}catch{}try{l?.delete?.()}catch{}try{c?.delete?.()}catch{}try{d?.delete?.()}catch{}try{h?.delete?.()}catch{}try{g?.delete?.()}catch{}f((e=>e+"\nCleanup complete"))}},children:h?"Processing...":"Process Image"}),(0,s.jsx)("button",{id:"resetBtn",type:"button",className:"btn btn-ghost",onClick:()=>{x([]),d("Waiting for image..."),u(!1),f("");const i=e.current,a=t.current;try{i?.getContext("2d")?.clearRect(0,0,i.width,i.height)}catch{}try{a?.getContext("2d")?.clearRect(0,0,a.width,a.height)}catch{}const r=document.getElementById("leafInfo");r&&(r.innerHTML="<p>Ready. Results will appear here after processing.</p>"),n.current&&(n.current.value="")},children:"Reset"}),(0,s.jsx)("button",{id:"downloadBtn",type:"button",disabled:!p.length,className:"btn btn-blue",title:"Download results as CSV",onClick:()=>{if(!p.length)return void M("No data to download. Please process an image first.","warning");const e=[["Sample ID","Length","Width","Area","Perimeter","Aspect Ratio","MeanB","MeanG","MeanR","MeanH","MeanS","MeanV","Unit","AreaUnit"].join(",")];p.forEach((t=>{e.push([t.id,t.length.toFixed(2),t.width.toFixed(2),t.area.toFixed(2),t.perimeter.toFixed(2),t.aspect.toFixed(3),t.meanB.toFixed(1),t.meanG.toFixed(1),t.meanR.toFixed(1),t.meanH.toFixed(1),t.meanS.toFixed(1),t.meanV.toFixed(1),t.unit,t.areaUnit].join(","))}));const t=new Blob(["\ufeff"+e.join("\n")],{type:"text/csv;charset=utf-8;"}),n=URL.createObjectURL(t),i=document.createElement("a");i.href=n,i.download=`image_metrics_${(new Date).toISOString().slice(0,19)}.csv`,document.body.appendChild(i),i.click(),i.remove(),URL.revokeObjectURL(n)},children:"Download CSV"})]}),(0,s.jsxs)("div",{className:"canvas-grid",children:[(0,s.jsx)(l,{title:"Original Image",children:(0,s.jsx)("canvas",{id:"captureCanvas",ref:e,width:"800",height:"600",className:"canvas-box"})}),(0,s.jsx)(l,{title:"Processed Result",children:(0,s.jsx)("div",{id:"processedContainer",children:(0,s.jsx)("canvas",{id:"processCanvas",ref:t,width:"800",height:"600",className:"canvas-box"})})})]}),(0,s.jsx)("div",{className:"guide-panel",children:(0,s.jsx)(l,{title:"Shooting Guide",children:(0,s.jsxs)("div",{className:"guide-content",children:[(0,s.jsxs)("div",{className:"guide-text",children:[(0,s.jsx)("h4",{children:"For best analysis results:"}),(0,s.jsxs)("ul",{children:[(0,s.jsx)("li",{children:"Use a solid background (white or black works best)"}),(0,s.jsx)("li",{children:"Place a coin or square card in the top-left area"}),(0,s.jsx)("li",{children:"Ensure samples are separated, not overlapping"}),(0,s.jsx)("li",{children:"Provide even lighting and avoid shadows"}),(0,s.jsx)("li",{children:"Keep the camera parallel to the sample plane to reduce perspective distortion"})]})]}),(0,s.jsx)("div",{className:"guide-visual",children:(0,s.jsxs)("div",{className:"guide-demo",children:[(0,s.jsx)("div",{className:"reference-area",children:"Reference area"}),(0,s.jsx)("div",{className:"samples-area",children:"Samples area"})]})})]})})}),(0,s.jsx)("div",{className:"metrics-panel",children:(0,s.jsx)(l,{title:"Quantified Results",children:(0,s.jsx)("div",{id:"leafInfo",children:p.length?(0,s.jsx)(c,{rows:p}):(0,s.jsx)("p",{children:"Ready. After processing, sample measurements will appear here."})})})})]})]})}const l=({title:e,children:t})=>(0,s.jsxs)("div",{className:"panel",children:[(0,s.jsx)("div",{className:"panel-title",children:e}),t]});function c({rows:e}){return(0,s.jsxs)("div",{className:"results-wrapper",children:[(0,s.jsxs)("table",{className:"results-table",children:[(0,s.jsx)("thead",{children:(0,s.jsxs)("tr",{children:[(0,s.jsx)("th",{children:"Sample ID"}),(0,s.jsx)("th",{children:"Length (mm/px)"}),(0,s.jsx)("th",{children:"Width (mm/px)"}),(0,s.jsx)("th",{children:"Area (mm\xb2/px\xb2)"}),(0,s.jsx)("th",{children:"Perimeter (mm/px)"}),(0,s.jsx)("th",{children:"Aspect Ratio"}),(0,s.jsx)("th",{children:"Mean B"}),(0,s.jsx)("th",{children:"Mean G"}),(0,s.jsx)("th",{children:"Mean R"}),(0,s.jsx)("th",{children:"Mean H"}),(0,s.jsx)("th",{children:"Mean S"}),(0,s.jsx)("th",{children:"Mean V"})]})}),(0,s.jsx)("tbody",{children:e.slice(-50).map((e=>(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:e.id}),(0,s.jsxs)("td",{children:[e.length.toFixed(2)," ",e.unit]}),(0,s.jsxs)("td",{children:[e.width.toFixed(2)," ",e.unit]}),(0,s.jsxs)("td",{children:[e.area.toFixed(2)," ",e.areaUnit]}),(0,s.jsxs)("td",{children:[e.perimeter.toFixed(2)," ",e.unit]}),(0,s.jsx)("td",{children:e.aspect.toFixed(3)}),(0,s.jsx)("td",{children:e.meanB.toFixed(1)}),(0,s.jsx)("td",{children:e.meanG.toFixed(1)}),(0,s.jsx)("td",{children:e.meanR.toFixed(1)}),(0,s.jsx)("td",{children:e.meanH.toFixed(1)}),(0,s.jsx)("td",{children:e.meanS.toFixed(1)}),(0,s.jsx)("td",{children:e.meanV.toFixed(1)})]},e.id)))})]}),e.length>50&&(0,s.jsxs)("div",{className:"note",children:["... ",e.length-50," more samples. Download CSV for full results."]})]})}}}]);